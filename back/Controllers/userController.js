// Controllers/userController.js
import bcrypt from "bcrypt";
import * as UserModel from "../Models/userModel.js";
import { sendCredentialsEmail } from "../Services/emailService.js";

/** GET /users */
export const getUsers = async (req, res) => {
  try {
    const users = await UserModel.getAllWithPersona();
    res.json({ success: true, users });
  } catch (err) {
    console.error("[ERROR] getUsers controller:", { message: err.message, stack: err.stack });
    res.status(500).json({ success: false, error: "Error al obtener usuarios" });
  }
};

/** GET /users/:id */
export const getUserById = async (req, res) => {
  try {
    const id = req.params.id;
    const user = await UserModel.getByIdWithPersona(id);
    if (!user) return res.status(404).json({ success: false, error: "Usuario no encontrado" });
    res.json({ success: true, user });
  } catch (err) {
    console.error("[ERROR] getUserById controller:", { params: req.params, message: err.message, stack: err.stack });
    res.status(500).json({ success: false, error: "Error al obtener usuario" });
  }
};

/** POST /login */
export const loginUser = async (req, res) => {
  try {
    const { email, password } = req.body;
    if (!email || !password) {
      console.warn("[WARN] loginUser - missing fields", { body: { ...req.body, password: "[REDACTED]" } });
      return res.status(400).json({ success: false, error: "Email y contrase帽a son requeridos" });
    }

    const user = await UserModel.loginUser(email);
    if (!user) {
      console.warn("[WARN] loginUser - user not found", { email });
      return res.status(401).json({ success: false, error: "Usuario o contrase帽a incorrectos" });
    }

    //  validar contrase帽a encriptada
    console.log("[INFO] Comparing password with hash");
    const validPass = await bcrypt.compare(password, user.password);
    if (!validPass) {
      console.warn("[WARN] loginUser - invalid password for", { email });
      console.log("[DEBUG] Password length:", password.length, "Hash starts:", user.password.substring(0, 10));
      return res.status(401).json({ success: false, error: "Usuario o contrase帽a incorrectos" });
    }

    console.log("[INFO] Login successful for", { email, username: user.username });
    res.json({
      success: true,
      user: {
        id: user.id,
        username: user.username,
        email: user.email,
        role: user.role,
        state: user.state,
      },
    });
  } catch (err) {
    console.error("[ERROR] loginUser controller:", { body: { ...req.body, password: "[REDACTED]" }, message: err.message, stack: err.stack });
    res.status(500).json({ success: false, error: "Error al iniciar sesi贸n" });
  }
};

/** POST /users -> crea user + person reciclador con contrase帽a temporal */
export const createUser = async (req, res) => {
  try {
    console.log("[INFO] POST /users body:", { ...req.body, password: undefined });
    const { nombres, apellidos, email, phone, role_id } = req.body;

    if (!nombres || !apellidos || !email || !phone) {
      console.warn("[WARN] createUser - missing fields", { body: req.body });
      return res.status(400).json({ success: false, error: "Campos requeridos: nombres, apellidos, email, phone" });
    }
    if (typeof email !== "string" || !email.includes("@")) {
      console.warn("[WARN] createUser - invalid email", { email });
      return res.status(400).json({ success: false, error: "Email inv谩lido" });
    }

    // Usa el role_id recibido o por defecto 3 (reciclador)
    const roleId = role_id !== undefined ? Number(role_id) : 3;

    try {
      const result = await UserModel.createWithPersona(
        nombres,
        apellidos,
        email,
        phone,
        roleId
      );

      console.log("[INFO] createUser - result from model:", { 
        userId: result.userId, 
        hasPassword: !!result.password 
      });

      res.status(201).json({
        success: true,
        id: result.userId,
        personId: result.personId,
        tempPassword: result.password,
      });

      if (result.password) {
        console.log("[INFO] Sending credentials email with generated password");
        await sendCredentialsEmail(email, nombres, apellidos, email, result.password);
      } else {
        console.warn("[WARN] No password generated by model, cannot send email");
      }

    } catch (err) {
      console.error("[ERROR] createUser model error:", {
        body: req.body,
        message: err.message,
        code: err.code || null,
        stack: err.stack,
      });
      if (err.code === "ER_ROLE_NOT_FOUND" || err.code === "ER_NO_ROLES") {
        return res.status(400).json({ success: false, error: err.message });
      }
      if (err && err.code === "ER_NO_REFERENCED_ROW_2") {
        return res.status(400).json({
          success: false,
          error: "Violaci贸n de FK al crear usuario (verifica role/foreign keys)",
          detail: err.sqlMessage || err.message,
        });
      }
      throw err;
    }
  } catch (err) {
    console.error("[ERROR] createUser controller unexpected:", { body: req.body, message: err.message, stack: err.stack });
    res.status(500).json({ success: false, error: "Error al registrar usuario", detail: err.message });
  }
};


/** POST /users/collector -> crea user + persona de recolector con state = 0 */
export const createCollectorUser = async (req, res) => {
  try {
    const { nombres, apellidos, email, phone } = req.body;

    if (!nombres || !apellidos || !email || !phone) {
      return res.status(400).json({
        success: false,
        error: "Campos requeridos: nombres, apellidos, email, phone",
      });
    }

    // role_id fijo para recolector
    const roleId = 2;
    const state = 0; // pendiente

    const result = await UserModel.createCollectorWithPersona(
      nombres,
      apellidos,
      email,
      phone,
      roleId,
      state
    );

    res.status(201).json({
      success: true,
      message: "Registro de recolector creado con estado pendiente. Espera aprobaci贸n del administrador.",
      id: result.userId,
      personId: result.personId,
    });

  } catch (err) {
    console.error("[ERROR] createCollectorUser:", {
      body: req.body,
      message: err.message,
      stack: err.stack,
    });
    res.status(500).json({
      success: false,
      error: "Error al registrar usuario recolector",
      detail: err.message,
    });
  }
};



/** PUT /users/:id */
export const updateUser = async (req, res) => {
  try {
    const id = req.params.id;
    const { nombres, apellidos, username, email, phone, role_id, state } = req.body;
    const roleIdParsed = role_id !== undefined ? Number(role_id) : undefined;

    const updated = await UserModel.updateWithPersona(
      id,
      nombres,
      apellidos,
      username,
      email,
      phone,
      roleIdParsed,
      state
    );

    if (!updated) return res.status(404).json({ success: false, error: "Usuario no encontrado" });
    res.json({ success: true });
  } catch (err) {
    console.error("[ERROR] updateUser controller:", { params: req.params, body: req.body, message: err.message, stack: err.stack });
    res.status(500).json({ success: false, error: "Error al actualizar usuario" });
  }
};

/** DELETE /users/:id */
export const deleteUser = async (req, res) => {
  try {
    const id = req.params.id;
    const deleted = await UserModel.softDeleteWithPersona(id);
    if (!deleted) return res.status(404).json({ success: false, error: "Usuario no encontrado" });
    res.json({ success: true });
  } catch (err) {
    console.error("[ERROR] deleteUser controller:", { params: req.params, message: err.message, stack: err.stack });
    res.status(500).json({ success: false, error: "Error al eliminar usuario" });
  }
};

/** PUT /users/changePassword/:userId */
export const changePassword = async (req, res) => {
  try {
    const { userId } = req.params;
    const { password } = req.body;
    if (!password) return res.status(400).json({ success: false, error: "La contrase帽a es requerida" });

    const user = await UserModel.getById(userId);
    if (!user) return res.status(404).json({ success: false, error: "Usuario no encontrado" });

    const hashedPassword = await bcrypt.hash(password, 10);
    const updated = await UserModel.updatePasswordAndState(userId, hashedPassword);
    if (!updated) return res.status(500).json({ success: false, error: "No se pudo actualizar la contrase帽a" });

    res.json({ success: true, message: "Contrase帽a cambiada correctamente" });
  } catch (err) {
    console.error("[ERROR] changePassword controller:", { params: req.params, message: err.message, stack: err.stack });
    res.status(500).json({ success: false, error: "Error al cambiar la contrase帽a" });
  }
};


//Insitution User Model

/** POST /users/institution -> crea user + institution (pendiente, sin contrase帽a) */
export const createUserWithInstitution = async (req, res) => {
  try {
    const { companyName, nit, email, phone, role_id } = req.body;
    if (!companyName || !nit || !email || !phone) {
      return res.status(400).json({
        success: false,
        error: "Campos requeridos: companyName, nit, email, phone",
      });
    }

    const roleIdParsed = role_id !== undefined ? Number(role_id) : 3; 

    // El modelo debe crear el usuario con password: null y state: 0
    const result = await UserModel.createWithInstitution(
      companyName,
      nit,
      email,
      phone,
      roleIdParsed,
      0 // state pendiente
    );

    res.status(201).json({
      success: true,
      id: result.userId,
      institutionId: result.institutionId,
      state: 0
    });

    // No enviar correo ni contrase帽a aqu铆
  } catch (err) {
    console.error("[ERROR] createUserWithInstitution:", { body: req.body, message: err.message });
    res.status(500).json({ success: false, error: "Error al registrar usuario con instituci贸n" });
  }
};

/** PUT /users/institution/:id */
export const updateUserWithInstitution = async (req, res) => {
  try {
    const id = req.params.id;
    const { companyName, nit, username, email, phone, role_id, state } = req.body;

    const updated = await UserModel.updateWithInstitution(
      id,
      companyName,
      nit,
      username,
      email,
      phone,
      role_id,
      state
    );

    if (!updated) return res.status(404).json({ success: false, error: "Usuario/Instituci贸n no encontrado" });
    res.json({ success: true });
  } catch (err) {
    console.error("[ERROR] updateUserWithInstitution:", { message: err.message });
    res.status(500).json({ success: false, error: "Error al actualizar usuario con instituci贸n" });
  }
};

/** DELETE /users/institution/:id */
export const deleteUserWithInstitution = async (req, res) => {
  try {
    const id = req.params.id;
    const deleted = await UserModel.softDeleteWithInstitution(id);
    if (!deleted) return res.status(404).json({ success: false, error: "Usuario/Instituci贸n no encontrado" });
    res.json({ success: true });
  } catch (err) {
    console.error("[ERROR] deleteUserWithInstitution:", { message: err.message });
    res.status(500).json({ success: false, error: "Error al eliminar usuario con instituci贸n" });
  }
};


/** GET /users/withInstitution */
export const getUsersWithInstitution = async (req, res) => {
  try {
    const users = await UserModel.getAllWithInstitution();
    res.json({ success: true, users });
  } catch (err) {
    console.error("[ERROR] getUsersWithInstitution:", { message: err.message });
    res.status(500).json({ success: false, error: "Error al obtener usuarios con instituci贸n" });
  }
};

/** GET /users/withInstitution/:id */
export const getUserWithInstitutionById = async (req, res) => {
  try {
    const id = req.params.id;
    const user = await UserModel.getInstitutionById(id);
    if (!user) return res.status(404).json({ success: false, error: "Usuario/Instituci贸n no encontrado" });
    res.json({ success: true, user });
  } catch (err) {
    console.error("[ERROR] getUserWithInstitutionById:", { id, message: err.message });
    res.status(500).json({ success: false, error: "Error al obtener usuario con instituci贸n" });
  }
};

/** POST /users/registerCollector */
export const registerCollector = async (req, res) => {
  try {
    // Registro de instituci贸n
    if (req.body.companyName && req.body.nit) {
      if (!req.body.companyName || !req.body.nit || !req.body.email || !req.body.phone) {
        return res.status(400).json({
          success: false,
          error: "Campos requeridos: companyName, nit, email, phone",
        });
      }
      // Crear usuario
      const user = await UserModel.create({
        email: req.body.email,
        phone: req.body.phone,
        role_id: 3,
        state: 0,
      });
      // Crear instituci贸n
      const institution = await InstitutionModel.create({
        companyName: req.body.companyName,
        nit: req.body.nit,
        userId: user.id,
        state: 0,
      });
      return res.status(201).json({ success: true, userId: user.id, institutionId: institution.id });
    }

    // Registro de persona
    if (req.body.nombres && req.body.apellidos) {
      if (!req.body.nombres || !req.body.apellidos || !req.body.email || !req.body.phone) {
        return res.status(400).json({
          success: false,
          error: "Campos requeridos: nombres, apellidos, email, phone",
        });
      }
      const user = await UserModel.create({
        nombres: req.body.nombres,
        apellidos: req.body.apellidos,
        email: req.body.email,
        phone: req.body.phone,
        role_id: 2,
        state: 0,
      });
      
      return res.status(201).json({ success: true, userId: user.id });
    }

    // Si no es ninguno de los dos
    return res.status(400).json({
      success: false,
      error: "Datos insuficientes para registrar persona o instituci贸n",
    });
  } catch (err) {
    console.error("[ERROR] registerCollector:", err);
    return res.status(500).json({ success: false, error: "Error en el registro" });
  }
};