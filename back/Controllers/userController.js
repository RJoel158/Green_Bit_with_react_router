// Controllers/userController.js
import bcrypt from "bcrypt";
import * as UserModel from "../Models/userModel.js";
import { sendCredentialsEmail } from "../Services/emailService.js";

/** GET /users */
export const getUsers = async (req, res) => {
  try {
    const users = await UserModel.getAllWithPersona();
    res.json({ success: true, users });
  } catch (err) {
    console.error("[ERROR] getUsers controller:", { message: err.message, stack: err.stack });
    res.status(500).json({ success: false, error: "Error al obtener usuarios" });
  }
};

/** GET /users/:id */
export const getUserById = async (req, res) => {
  try {
    const id = req.params.id;
    const user = await UserModel.getByIdWithPersona(id);
    if (!user) return res.status(404).json({ success: false, error: "Usuario no encontrado" });
    res.json({ success: true, user });
  } catch (err) {
    console.error("[ERROR] getUserById controller:", { params: req.params, message: err.message, stack: err.stack });
    res.status(500).json({ success: false, error: "Error al obtener usuario" });
  }
};

/** POST /login */
export const loginUser = async (req, res) => {
  try {
    const { email, password } = req.body;
    if (!email || !password) {
      console.warn("[WARN] loginUser - missing fields", { body: { ...req.body, password: "[REDACTED]" } });
      return res.status(400).json({ success: false, error: "Email y contrase침a son requeridos" });
    }

    const user = await UserModel.loginUser(email);
    if (!user) {
      console.warn("[WARN] loginUser - user not found", { email });
      return res.status(401).json({ success: false, error: "Usuario o contrase침a incorrectos" });
    }

    // 游댏 validar contrase침a encriptada
    console.log("[INFO] Comparing password with hash");
    const validPass = await bcrypt.compare(password, user.password);
    if (!validPass) {
      console.warn("[WARN] loginUser - invalid password for", { email });
      console.log("[DEBUG] Password length:", password.length, "Hash starts:", user.password.substring(0, 10));
      return res.status(401).json({ success: false, error: "Usuario o contrase침a incorrectos" });
    }

    console.log("[INFO] Login successful for", { email, username: user.username });
    res.json({
      success: true,
      user: {
        id: user.id,
        username: user.username,
        email: user.email,
        role: user.role,
        state: user.state,
      },
    });
  } catch (err) {
    console.error("[ERROR] loginUser controller:", { body: { ...req.body, password: "[REDACTED]" }, message: err.message, stack: err.stack });
    res.status(500).json({ success: false, error: "Error al iniciar sesi칩n" });
  }
};

/** POST /users -> crea user + person reciclador con contrase침a temporal */
export const createUser = async (req, res) => {
  try {
    console.log("[INFO] POST /users body:", { ...req.body, password: undefined });
    const { nombres, apellidos, email, phone, role_id } = req.body;

    if (!nombres || !apellidos || !email || !phone) {
      console.warn("[WARN] createUser - missing fields", { body: req.body });
      return res.status(400).json({ success: false, error: "Campos requeridos: nombres, apellidos, email, phone" });
    }
    if (typeof email !== "string" || !email.includes("@")) {
      console.warn("[WARN] createUser - invalid email", { email });
      return res.status(400).json({ success: false, error: "Email inv치lido" });
    }

    // Usa el role_id recibido o por defecto 3 (reciclador)
    const roleId = role_id !== undefined ? Number(role_id) : 3;

    try {
      const result = await UserModel.createWithPersona(
        nombres,
        apellidos,
        email,
        phone,
        roleId
      );

      console.log("[INFO] createUser - result from model:", { 
        userId: result.userId, 
        hasPassword: !!result.password 
      });

      res.status(201).json({
        success: true,
        id: result.userId,
        personId: result.personId,
        tempPassword: result.password,
      });

      if (result.password) {
        console.log("[INFO] Sending credentials email with generated password");
        await sendCredentialsEmail(email, nombres, apellidos, email, result.password);
      } else {
        console.warn("[WARN] No password generated by model, cannot send email");
      }

    } catch (err) {
      console.error("[ERROR] createUser model error:", {
        body: req.body,
        message: err.message,
        code: err.code || null,
        stack: err.stack,
      });
      if (err.code === "ER_ROLE_NOT_FOUND" || err.code === "ER_NO_ROLES") {
        return res.status(400).json({ success: false, error: err.message });
      }
      if (err && err.code === "ER_NO_REFERENCED_ROW_2") {
        return res.status(400).json({
          success: false,
          error: "Violaci칩n de FK al crear usuario (verifica role/foreign keys)",
          detail: err.sqlMessage || err.message,
        });
      }
      throw err;
    }
  } catch (err) {
    console.error("[ERROR] createUser controller unexpected:", { body: req.body, message: err.message, stack: err.stack });
    res.status(500).json({ success: false, error: "Error al registrar usuario", detail: err.message });
  }
};


/** POST /users/collector -> crea user + persona de recolector con state = 0 */
export const createCollectorUser = async (req, res) => {
  try {
    const { nombres, apellidos, email, phone } = req.body;

    if (!nombres || !apellidos || !email || !phone) {
      return res.status(400).json({
        success: false,
        error: "Campos requeridos: nombres, apellidos, email, phone",
      });
    }

    // role_id fijo para recolector
    const roleId = 2;
    const state = 0; // pendiente

    const result = await UserModel.createCollectorWithPersona(
      nombres,
      apellidos,
      email,
      phone,
      roleId,
      state
    );

    res.status(201).json({
      success: true,
      message: "Registro de recolector creado con estado pendiente. Espera aprobaci칩n del administrador.",
      id: result.userId,
      personId: result.personId,
    });

  } catch (err) {
    console.error("[ERROR] createCollectorUser:", {
      body: req.body,
      message: err.message,
      stack: err.stack,
    });
    res.status(500).json({
      success: false,
      error: "Error al registrar usuario recolector",
      detail: err.message,
    });
  }
};



/** PUT /users/:id */
export const updateUser = async (req, res) => {
  try {
    const id = req.params.id;
    const { nombres, apellidos, username, email, phone, role_id, state } = req.body;
    const roleIdParsed = role_id !== undefined ? Number(role_id) : undefined;

    const updated = await UserModel.updateWithPersona(
      id,
      nombres,
      apellidos,
      username,
      email,
      phone,
      roleIdParsed,
      state
    );

    if (!updated) return res.status(404).json({ success: false, error: "Usuario no encontrado" });
    res.json({ success: true });
  } catch (err) {
    console.error("[ERROR] updateUser controller:", { params: req.params, body: req.body, message: err.message, stack: err.stack });
    res.status(500).json({ success: false, error: "Error al actualizar usuario" });
  }
};

/** DELETE /users/:id */
export const deleteUser = async (req, res) => {
  try {
    const id = req.params.id;
    const deleted = await UserModel.softDeleteWithPersona(id);
    if (!deleted) return res.status(404).json({ success: false, error: "Usuario no encontrado" });
    res.json({ success: true });
  } catch (err) {
    console.error("[ERROR] deleteUser controller:", { params: req.params, message: err.message, stack: err.stack });
    res.status(500).json({ success: false, error: "Error al eliminar usuario" });
  }
};

/** PUT /users/changePassword/:userId */
export const changePassword = async (req, res) => {
  try {
    const { userId } = req.params;
    const { password } = req.body;
    if (!password) return res.status(400).json({ success: false, error: "La contrase침a es requerida" });

    const user = await UserModel.getById(userId);
    if (!user) return res.status(404).json({ success: false, error: "Usuario no encontrado" });

    const hashedPassword = await bcrypt.hash(password, 10);
    const updated = await UserModel.updatePasswordAndState(userId, hashedPassword);
    if (!updated) return res.status(500).json({ success: false, error: "No se pudo actualizar la contrase침a" });

    res.json({ success: true, message: "Contrase침a cambiada correctamente" });
  } catch (err) {
    console.error("[ERROR] changePassword controller:", { params: req.params, message: err.message, stack: err.stack });
    res.status(500).json({ success: false, error: "Error al cambiar la contrase침a" });
  }
};


//Insitution User Model

/** POST /users/institution -> crea user + institution (pendiente, sin contrase침a) */
export const createUserWithInstitution = async (req, res) => {
  try {
    const { companyName, nit, email, phone, role_id } = req.body;
    if (!companyName || !nit || !email || !phone) {
      return res.status(400).json({
        success: false,
        error: "Campos requeridos: companyName, nit, email, phone",
      });
    }

    const roleIdParsed = role_id !== undefined ? Number(role_id) : 3; 

    // El modelo debe crear el usuario con password: null y state: 0
    const result = await UserModel.createWithInstitution(
      companyName,
      nit,
      email,
      phone,
      roleIdParsed,
      0 // state pendiente
    );

    res.status(201).json({
      success: true,
      id: result.userId,
      institutionId: result.institutionId,
      state: 0
    });

    // No enviar correo ni contrase침a aqu칤
  } catch (err) {
    console.error("[ERROR] createUserWithInstitution:", { body: req.body, message: err.message });
    res.status(500).json({ success: false, error: "Error al registrar usuario con instituci칩n" });
  }
};

/** PUT /users/institution/:id */
export const updateUserWithInstitution = async (req, res) => {
  try {
    const id = req.params.id;
    const { companyName, nit, username, email, phone, role_id, state } = req.body;

    const updated = await UserModel.updateWithInstitution(
      id,
      companyName,
      nit,
      username,
      email,
      phone,
      role_id,
      state
    );

    if (!updated) return res.status(404).json({ success: false, error: "Usuario/Instituci칩n no encontrado" });
    res.json({ success: true });
  } catch (err) {
    console.error("[ERROR] updateUserWithInstitution:", { message: err.message });
    res.status(500).json({ success: false, error: "Error al actualizar usuario con instituci칩n" });
  }
};

/** DELETE /users/institution/:id */
export const deleteUserWithInstitution = async (req, res) => {
  try {
    const id = req.params.id;
    const deleted = await UserModel.softDeleteWithInstitution(id);
    if (!deleted) return res.status(404).json({ success: false, error: "Usuario/Instituci칩n no encontrado" });
    res.json({ success: true });
  } catch (err) {
    console.error("[ERROR] deleteUserWithInstitution:", { message: err.message });
    res.status(500).json({ success: false, error: "Error al eliminar usuario con instituci칩n" });
  }
};


/** GET /users/withInstitution */
export const getUsersWithInstitution = async (req, res) => {
  try {
    const users = await UserModel.getAllWithInstitution();
    res.json({ success: true, users });
  } catch (err) {
    console.error("[ERROR] getUsersWithInstitution:", { message: err.message });
    res.status(500).json({ success: false, error: "Error al obtener usuarios con instituci칩n" });
  }
};

/** GET /users/withInstitution/:id */
export const getUserWithInstitutionById = async (req, res) => {
  try {
    const id = req.params.id;
    const user = await UserModel.getInstitutionById(id);
    if (!user) return res.status(404).json({ success: false, error: "Usuario/Instituci칩n no encontrado" });
    res.json({ success: true, user });
  } catch (err) {
    console.error("[ERROR] getUserWithInstitutionById:", { id, message: err.message });
    res.status(500).json({ success: false, error: "Error al obtener usuario con instituci칩n" });
  }
};

/** POST /users/registerCollector */
export const registerCollector = async (req, res) => {
  try {
    // Registro de instituci칩n
    if (req.body.companyName && req.body.nit) {
      if (!req.body.companyName || !req.body.nit || !req.body.email || !req.body.phone) {
        return res.status(400).json({
          success: false,
          error: "Campos requeridos: companyName, nit, email, phone",
        });
      }
      // Crear usuario
      const user = await UserModel.create({
        email: req.body.email,
        phone: req.body.phone,
        role_id: 3,
        state: 0,
      });
      // Crear instituci칩n
      const institution = await InstitutionModel.create({
        companyName: req.body.companyName,
        nit: req.body.nit,
        userId: user.id,
        state: 0,
      });
      return res.status(201).json({ success: true, userId: user.id, institutionId: institution.id });
    }

    // Registro de persona
    if (req.body.nombres && req.body.apellidos) {
      if (!req.body.nombres || !req.body.apellidos || !req.body.email || !req.body.phone) {
        return res.status(400).json({
          success: false,
          error: "Campos requeridos: nombres, apellidos, email, phone",
        });
      }
      const user = await UserModel.create({
        nombres: req.body.nombres,
        apellidos: req.body.apellidos,
        email: req.body.email,
        phone: req.body.phone,
        role_id: 2,
        state: 0,
      });
      
      return res.status(201).json({ success: true, userId: user.id });
    }

    // Si no es ninguno de los dos
    return res.status(400).json({
      success: false,
      error: "Datos insuficientes para registrar persona o instituci칩n",
    });
  } catch (err) {
    console.error("[ERROR] registerCollector:", err);
    return res.status(500).json({ success: false, error: "Error en el registro" });
  }
};
//Recuperacion de contrase침a
export const forgotPassword = async (req, res) => {
  try {
    const { email } = req.body;

    if (!email) {
      console.warn("[WARN] forgotPassword - missing email", { body: req.body });
      return res.status(400).json({ 
        success: false, 
        error: "El correo electr칩nico es requerido" 
      });
    }

    // Validar formato de email
    if (typeof email !== "string" || !email.includes("@")) {
      console.warn("[WARN] forgotPassword - invalid email", { email });
      return res.status(400).json({ 
        success: false, 
        error: "Email inv치lido" 
      });
    }

    // Buscar usuario por email
    const user = await UserModel.loginUser(email);
    
    if (!user) {
      console.warn("[WARN] forgotPassword - user not found", { email });
      
      return res.status(200).json({ 
        success: true, 
        message: "Si el correo existe, recibir치s instrucciones para recuperar tu contrase침a" 
      });
    }

  
    // Generar nueva contrase침a temporal usando el ID del usuario
    const result = await UserModel.resetPasswordWithTemp(user.id);

    console.log("[INFO] forgotPassword - password reset successful", { 
      email, 
      userId: user.id 
    });

    // Enviar email con la contrase침a temporal
    try {
     
      const userDetails = await UserModel.getByIdWithPersona(user.id);
      
      await sendCredentialsEmail(
        email,
        userDetails?.firstname || "Usuario",
        userDetails?.lastname || "",
        email,
        result.tempPassword,
        //Se envia el valor 1 para cambiar el contenido del correo
        1
      );
      console.log("[INFO] forgotPassword - email sent successfully to", { email });
    } catch (emailErr) {
      console.error("[ERROR] forgotPassword - failed to send email:", {
        email,
        message: emailErr.message
      });
     
    }

    res.json({ 
      success: true, 
      message: "Se ha enviado una contrase침a temporal a tu correo electr칩nico" 
    });

  } catch (err) {
    console.error("[ERROR] forgotPassword controller:", { 
      body: req.body, 
      message: err.message, 
      stack: err.stack 
    });
    res.status(500).json({ 
      success: false, 
      error: "Error al procesar la solicitud de recuperaci칩n" 
    });
  }
};